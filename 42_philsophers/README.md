# 42_philosophers

철학이 그렇게 치명적일 것이라곤 생각 못했다.


*요약 : 이 프로젝트에서는 프로세스 스레딩의 기본적인 부분에 대해 학습합니다. 스레드를 어떻게 만드는지, 뮤텍스가 무엇인지 학습합니다.*


*version : 9*


## Chapter 1 - 소개


철학은 존재, 지식, 가치, 이성, 정신, 언어에 관한 일반적이고 근본적인 질문들을 연구하는 학문이다.
이러한 질문들은 종종 공부하거나 해결해야 할 문제로 제기된다. 그 용어는 아마도 피타고라스 (기원전 570년경 – 495년)에 의해 만들어졌을 것이다.
철학적 방법에는 질문, 비판적 토론, 이성적 주장, 체계적인 표현이 포함된다. 고전적인 철학적 질문은 다음과 같다. 어떤 것을 알고 그것을 증명하는 것이 가능합니까? 무엇이 가장 진짜인가? 철학자들은 또한 다음과 같은 더 실질적이고 구체적인 질문을 제기한다:
어떻게 사는 게 최선인가? 정의로운 것이 더 나은가, 아니면 부당한 것이 더 나은가? 인간에게는 자유의지가 있는가?


역사적으로 "철학"은 어떤 지식도 포괄했다. 고대 그리스 철학자 아리스토텔레스의 시대부터 19세기까지 "자연철학"은 천문학, 의학, 물리학을 포괄했다. 예를 들어, 뉴턴의 1687년 자연철학의 수학적 원리는 후에 물리학 책으로 분류되었다. 근대에는 전통적으로 철학의 일부였던 일부 연구가 심리학, 사회학, 언어학, 경제학을 포함한 별도의 학문 분야가 되었다.


예술, 과학, 정치, 또는 다른 학문과 밀접하게 관련된 다른 연구들은 철학의 일부로 남아있었다. 예를 들어, 아름다움은 객관적인가 아니면 주관적인가? 많은 과학적 방법들이 있는가, 아니면 한 가지 방법뿐인가? 정치적 유토피아는 희망적인 꿈일까, 희망이 없는 환상일까?
학문철학의 주요 하위 분야로는 형이상학, 인식론, 윤리학, 미학, 정치철학, 논리학, 과학철학 등이 있다.


## Chapter 2 - 공통부

- 이 프로젝트는 반드시 C언어로 작성해야합니다.
- 프로젝트는 Norm 규정에 맞춰 작성되어야 합니다. 만약 보너스 파일과 함수를 작성했다면, 그것 역시 Norm 규정에 맞는지 체크하고 만약 내부에 norm error아 있다면, 0점을 받게 됩니다.
- 정의되지 않은 동작과는 별도로 함수가 의도치 않게 종료되어서는 안됩니다. (segmentation fault, bus error, double free 등). 만약 발생한다면 당신의 프로젝트는 작동하지 않는 것으로 간주되어 평가때 0점을 받게 됩니다.
- 모든 힙에서 할당된 메모리 공간은 적절하게 해제되어야 합니다. 메모리 누수는 용납되지 않습니다.
- 과제에서 요구한다면, 당신은 소스파일을 cc를 사용하여 -Wall, -Wextra and -Werror 옵션으로 컴파일할 Makefile을 제출해야 하고 Makefile은 relink 되어선 안됩니다.
- Makefile은 적어도 $(NAME), all, clean, fclean, re 규칙을 포함해야 합니다.
- 보너스 파트를 제출한다면 반드시 Makefile에 필수파트에서 금지된 모든 다양한 헤더, 라이브러리, 함수를 추가하는 bonus 규칙을 추가해야합니다. 보너스는 반드시 _bonus.{c/h}가 접미사에 붙는, 필수파트와 다른 파일로 제출해야합니다. 필수파트와 보너스파트는 서로 분리되어 평가받습니다.
- 프로젝트에서 당신의 libft를 허용한다면, libft폴더에 관련된 Makefile과 소스를 복사해야합니다. 프로젝트의 Makefile은 Makefile을 사용하여 라이브러리를 컴파일한 다음 프로젝트를 컴파일해야 합니다.
- 이 작업은 제출할 필요도 없고 채점도 되지 않을 것이므로 프로젝트를 위한 테스트 프로그램을 만들 것을 권장합니다. 평가를 쉽게 해줄 거예용. 디펜스때 이 테스트가 유용하다는 것을 알게 될 것입니다. 실제로 디펜스때 테스트를 자유롭게 사용할 수 있습니다.
- 할당된 깃 레포지토리에 작업물을 제출하세요. 깃 레포지토리에 들어있는 것만 채점될 것입니다. DeppThought가 작업물을 채점하도록 지정되면, 그것은 동료평가 이후에 이루어집니다. Deppthought의 평가 도중 작업의 어느부분에서 오류가 발생하면 평가가 중지됩니다.


## Chapter3 - 개요

이 프로젝트를 성공시키기 위해 알아야 할 것들.
- 한 명 이상의 철학자가 원탁에 앉아 밥을 먹거나, 생각을 하거나, 잠을 자고 있다. 그들은 먹는동안 자거나 생각하지 않는다; 생각하는동안 자거나 먹지 않는다; 물론 자는동안 생각하거나 먹지 않는다.
- 철학자는 스파게티가 있는 큰 그릇이 중앙에 있는 원탁에 앉는다.
- 탁자위에 포크가 몇개 있다. 하나의 포크로 스파게티를 옮기고 먹는 것은 매우 불편하기 때문에 그들은 양손에 포크를 들고 식사를 할 것이다.
- 철학자의 식사가 끝날때마다 포크를 놓고 잠을 자기 시작할 것이다. 잠을 다 자고 나면 그들은 생각하기 시작할 것이다. 철학자가 죽으면 시뮬레이션은 멈춘다.
- 모든 철학자는 반드시 식사를 해야하고 그들이 굶으면 안된다.
- 철학자는 서로 말하지 않는다.
- 철학자는 다른 철학자들이 언제 죽을지 모른다.
- 철학자들이 죽어선 안된다.

## Chapter4 - 기본 구조

필수파트 프로그램을 완성하고 또다른 보너스 파트 프로그램을 완성해야하지만 기본적인 규칙은 같다.
- 전역변수는 금지된다
- 프로그램은 인수로 다음 것들을 받는다 : number_of_philosophers, time_to_die, time_to_eat, time_to_sleep, [number_of_times_each_philosopher_must_eat]
  - number_of_philosophers : 철학자의 수이자 포크의 수
  - time_to_die : 밀리초 단위이며, 만약 철학자가 그들의 마지막 식사 시작시간이나 시뮬레이션이 시작된 후 'time_to_die' 밀리초가 지난 후 식사를 시작하지 않으면 죽는다.
  - time_to_eat : 밀리초 단위이며, 철학자가 식사하는데 걸리는 시간이다. 이 시간동안 그들은 두개의 포크를 갖고 있는다.
  - time_to_sleep : 밀리초 단위이며, 철학자가 자는데 사용하는 시간이다.
  - number_of_times_each_philosopher_must_eat : 선택적인 인수이며 철학자가 최소 'number_of_times_etach_must_eat'만큼 먹는 경우 시뮬레이션이 끝난다. 특정하지 않으면, 시뮬레이션은 철학자가 사망할 때만 끝난다.
- 각 철학자는 1부터 'number_of_philosophers' 사이의 숫자가 주어진다.
- 1번 철학자는 'number_of_philosophers'번 철학자 다음에 있다. N번 철학자는 'N-1'번 철학자와 'N+1'번 철학자 사이에 앉는다.
프로그램 로그에 관하여:
- 철학자의 상태변화는 반드시 다음과 같이 기록되어야 한다. (X는 철학자 번호, timestamp_in_ms는 현재시간):
  - timestamp_in_ms X has taken a fork
  - timestamp_in_ms X is eating
  - timestamp_in_ms X is sleeping
  - timestamp_in_ms X is thinking
  - timestamp_in_ms X died
- 출력된 상태가 다른 철학자의 상태와 엉키거나 경쟁해선 안된다.
- 철학자가 죽고 그 상태를 출력하는 시간이 10밀리초 보다 오래 걸려선 안된다.
- 다시한번, 철학자는 죽으면 안된다.


## Chapter5 - 필수파트
|||
|---|---|
| 프로그램 이름 | philo |
| 제출할 파일 | philo/ |
| Makefile | Yes |
| 인자 | number_of_philosophers, time_to_die, time_to_eat, time_to_sleep, [number_of_times_each_philosopher_must_eat] |
| 외부 함수 | <pre>memset, printf, malloc, free, write,<br>usleep, gettimeofday, pthread_create,<br>pthread_detach, pthread_join, pthread_mutex_init,<br>pthread_mutex_destroy, pthread_mutex_lock,<br>pthread_mutex_unlock</pre> |
| Libft 허용 여부 | No |
| 세부사항 | Mutex 와 Thread를 사용하는 철학자 |


필수파트의 구체적인 규칙 :
- 각 철학자는 쓰레드가 되어야 한다.
- 각 철학자 사이에 하나의 포크가 있어야 하므로, 만약 여러 철학자가 존재한다면 각 철학자의 왼쪽, 오른쪽에 포크가 있어야 한다.
- 각 철학자가 포크를 복제하는 것을 피하기 위해, 포크의 상태를 뮤텍스로 보호해야한다.

## Chapter6 - 보너스 파트
|||
|---|---|
| 프로그램 이름 | philo |
| 제출할 파일 | philo/ |
| Makefile | Yes |
| 인자 | number_of_philosophers, time_to_die, time_to_eat, time_to_sleep, [number_of_times_each_philosopher_must_eat] |
| 외부 함수 | <pre>memset, printf, malloc, free, write, fork, kill,<br>exit, pthread_create, pthread_detach, pthread_join,<br>usleep, gettimeofday, waitpid, sem_open, sem_close,<br>sem_post, sem_wait, sem_unlink</pre> |
| Libft 허용 여부 | No |
| 세부사항 | Process 와 Semaphore를 사용하는 철학자 |

보너스 부분의 경우, 프로그램은 이전과 동일한 인수를 사용하고 일반 지침 장에 설명된 대로 동작해야 한다. 구체적인 규칙은 다음과 같다:
- 모든 포크가 테이블 가운데에 있다.
- 메모리에는 상태가 없지만 사용 가능한 포크의 수는 세마포어로 표현된다.
- 각각의 철학자는 프로세스여야 하고 메인 프로세스는 철학자가 되어서는 안 된다.
